{
  "alias": "",
  "ctors": [],
  "fields": [],
  "interfaces": [],
  "methods": [],
  "subtype": "CLASS",
  "name": "Function",
  "summary": "Function is the base class for all global functions, methods and lambdas defined in Julian.\u003cbr\u003e\u003cbr\u003eFunction has the first-class property in Julian. Like all other classes, it inherits [Object]. What sets it apart from other classes is the ability to execute. To invoke a function, use \"()\" grammar with argument expressions listed between ( and ). For example,\u003cbr\u003e\u003cbr\u003e[code]\nfun(1, \"a\", someVal);[code: end] Since function is first-class instance, it can be assigned and passed around:\u003cbr\u003e\u003cbr\u003e[code]\nvoid fun(){};\nvar f \u003d fun;\nf();[code: end] The same can be done for methods (both instance and static) and lambdas.\u003cbr\u003e\u003cbr\u003eIn general, Function in Julian doesn\u0027t enforce a strong typing. When a Function type is declared somewhere, a function instance of any given signature can be passed in. By the time a function is invoked, the arguments will be checked strickly, and when the function returns, the return value\u0027s type will also be checked against the declared type. This behavior can be relaxed a little by [dynamic invocation](#invoke).\u003cbr\u003e\u003cbr\u003eThis class is neither instantiate nor extensible. For more detailed description on Function, see [Julian Tutorial].",
  "references": []
}